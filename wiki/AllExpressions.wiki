#summary Expressions grammar
<wiki:toc max_depth="3" />

= Expressions =
The grammar of expressions is specified by the following production:
<pre>_
expression:
    lambda-expression
    assignment-expression
    conditional-expression
    query-expression
_</pre>

== Lambda expressions ==
A lambda expression defines is a concise syntax to define delegates, simple interfaces or expression trees.
<pre>_
lambda-expression:
    lambda-signature *=>* expression
    lambda-signature *=>* block
_</pre>
<pre>_
lambda-signature:
    *(* explicit-lambda-parameter-list,,opt,, *)* 
    *(* identifier-list,,opt,, *)* 
    identifier
_</pre>
<pre>_
explicit-lambda-parameter-list:
    explicit-lambda-parameter
    explicit-lambda-parameter-list *,* explicit-lambda-parameter
_</pre>
<pre>_
explicit-lambda-parameter:
    type identifier
_</pre>

== Assignment expressions ==
An assignment expression modify the value of a variable or the value of a property.
<pre>_
assignment-expression:
    unary-expression assignment-operator expression
_</pre>
<pre>_
assignment-operator:
    *One of: = += -= *= /= %= &= |= ^= <<= >>= >>>=*
_</pre>

== Conditional expressions ==
A conditional expression evaluates an expression based on the value of a boolean expression.
<pre>_
conditional-expression:
    null-coalescing-expression
    null-coalescing-expression *?* expression *:* expression
_</pre>

== Null coalescing expressions ==
A null coalescing expression returns the evaluation of a first expression if non-null, otherwise the evaluation of a second expression.
<pre>_
null-coalescing-expression:
    conditional-or-expression
    conditional-or-expression *??* null-coalescing-expression
_</pre>

== Conditional or expressions ==
A conditional or expression returns the evaluation of a first boolean expression if true, otherwise the evaluation of a second expression.
<pre>_
conditional-or-expression:
    conditional-and-expression
    conditional-or-expression *||* conditional-and-expression
_</pre>

== Conditional and expressions ==
A conditional and expression returns the evaluation of a first boolean expression if false, otherwise the evaluation of a second expression.
<pre>_
conditional-and-expression:
    inclusive-or-expression
    conditional-and-expression *&&* inclusive-or-expression
_</pre>

== Inclusive or expressions ==
An inclusive or expression returns true if one of the boolean expression operands evaluates to true. If operands are of an integral type, a bitwise operation is performed.
<pre>_
inclusive-or-expression:
    exclusive-or-expression
    inclusive-or-expression *|* exclusive-or-expression
_</pre>

== Exclusive or expressions ==
An exclusive or expression returns true if the boolean expression operands evaluates to the different values. If operands are of an integral type, a bitwise operation is performed.
<pre>_
exclusive-or-expression:
    and-expression
    exclusive-or-expression *^* and-expression
_</pre>

== And expressions ==
The and expression returns true if both boolean expression operands evaluates to true. If operands are of an integral type, a bitwise operation is performed.
<pre>_
and-expression:
    equality-expression
    and-expression *&* equality-expression
_</pre>

== Equality expressions ==
An equality expression tests whether operand expressions are considered equal or different.
<pre>_
equality-expression:
    relational-expression
    equality-expression *==* relational-expression
    equality-expression *!=* relational-expression
_</pre>

== Relational expressions ==
A relational expression tests the order relation of operand expressions. When the operator is {{{instanceof}}} or {{{as}}} the left operand is compared to a specified type.
<pre>_
relational-expression:
    shift-expression
    relational-expression *<* shift-expression
    relational-expression *>* shift-expression
    relational-expression *<=* shift-expression
    relational-expression *>=* shift-expression
    relational-expression *instanceof* type
    relational-expression *as* type
_</pre>

== Shift expressions ==
A shift expression is used to shift the bits of an integral type.
<pre>_
shift-expression:
    additive-expression
    shift-expression *<<* additive-expression
    shift-expression *>>* additive-expression
    shift-expression *>>>* additive-expression
_</pre>

== Additive expressions ==
An additive expression adds or subtracts numeric types or delegate types. The addition is also used to build strings.
<pre>_
additive-expression:
    multiplicative-expression
    additive-expression *+* multiplicative-expression
    additive-expression *-* multiplicative-expression
_</pre>

== Multiplicative expressions ==
A multiplicative expression multiplies or divides numeric types.
<pre>_
multiplicative-expression:
    unary-expression
    multiplicative-expression *`*`* unary-expression
    multiplicative-expression */* unary-expression
    multiplicative-expression *%* unary-expression
_</pre>

== Unary expression ==
An unary expression applies an unary operator to an expression.
<pre>_
unary-expression:
    primary-expression
    *+* unary-expression
    *-* unary-expression
    *!* unary-expression
    *~* unary-expression
    *(* type *)* unary-expression
    pre-decrement-expression
    pre-increment-expression
_</pre>
<pre>_
pre-decrement-expression:
    *--* unary-expression
_</pre>
<pre>_
pre-increment-expression:
    *++* unary-expression
_</pre>

== Primary expressions ==
<pre>_
primary-expression:
    no-array-creation-expression
    array-creation-expression
_</pre>
<pre>_
no-array-creation-expression:
    literal
    identifier type-argument-list,,opt,, 
    *(* expression *)* 
    primary-expression *.* identifier type-argument-list,,opt,, 
    class-name *.* identifier type-argument-list,,opt,, 
    primary-expression *(* argument-list,,opt,, *)* 
    no-array-creation-expression *`[`* argument-list *`]`* 
    *this* 
    *super .* identifier
    *super `[`* argument-list *`]`* 
    *new* type *(* argument-list,,opt,, *)* object-or-collection-initializer,,opt,, 
    *new* type object-or-collection-initializer
    *new* anonymous-object-initializer
    *typeof (* type *)*  
    *typeof ( void )* 
    *sizeof (* expression *)* 
    post-decrement-expression
    post-increment-expression
_</pre>
<pre>_
post-decrement-expression:
    unary-expression *--* 
_</pre>
<pre>_
post-increment-expression:
    unary-expression *++* 
_</pre>`
<pre>_
argument-list:
    expression
    argument-list *,* expression
_</pre>