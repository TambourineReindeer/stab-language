#summary Statements grammar
<wiki:toc max_depth="3" />

= Statements =
The production of the grammar representing statements is:
<pre>_
statement:
    labeled-statement
    local-declaration-statement
    embedded-statement
    
embedded-statement:
    block
    empty-statement
    expression-statement
    if-statement
    switch-statement
    while-statement
    do-statement
    for-statement
    foreach-statement
    break-statement
    continue-statement
    goto-statement
    return-statement
    throw-statement
    try-statement
    synchronized-statement
    using-statement
    yield-statement
_</pre>
<pre>_
statement-list:
    statement
    statement-list statement
_</pre>

== Labeled statements ==
A label can be added to a statement. This label can be used by a {{{goto}}} statement to transfer control to this statement.
<pre>_
labeled-statement:
    identifier *:* statement
_</pre>

== Local declaration statements ==
The local declaration statement is used to declare and optionally initialize one or more local variables.
<pre>_
local-declaration-statement:
    type local-declarators *;* 
    *var* identifier *=* local-initializer *;* 
_</pre>
<pre>_
local-declarators:
    local-declarator
    local-declarators *,* local-declarator
_</pre>
<pre>_
local-declarator:
    identifier
    identifier *=* local-initializer
_</pre>
<pre>_
local-initializer:
    expression
    array-initializer
_</pre>

== Block statements ==
The block statement is used where a statement is required to perform multiple actions.
<pre>_
block:
    *{* statement-list,,opt,, *}*
_</pre>

== Empty statements ==
The empty statement is used where a statement is required but no actions have to be performed.
<pre>_
empty-statement:
    *;*
_</pre>

== Expression statements ==
The expression statement is used where a statement is required to evaluate an expression. Only method calls and assignments are allowed.
<pre>_
expression-statement:
    invocation-expression
    object-creation-expression
    assignement
    post-decrement-expression
    post-increment-expression
    pre-decrement-expression
    pre-increment-expression
_</pre>

== {{{if}}} statements ==
The {{{if}}} statement execute a statement based on the evaluation of a boolean expression.
<pre>_
if-statement:
    *if (* expression *)* embedded-statement
    *if (* expression *)* embedded-statement *else* embedded-statement
_</pre>

== {{{switch}}} statements ==
The {{{switch}}} statement executes a statement based on the evaluation of an ordinal or string expression.
<pre>_
switch-statement:
    *switch (* expression *) {* switch-sections,,opt,, *}*
_</pre>
<pre>_
switch-sections:
    switch-section
    switch-sections switch-section
_</pre>
<pre>_
switch-section:
    switch-labels statement-list
_</pre>
<pre>_
switch-labels:
    switch-label
    switch-labels switch-label
_</pre>
<pre>_
switch-label:
    *case* expression *:* 
    *default :*
_</pre>

== {{{while}}} statements ==
The {{{while}}} statement executes repeatedly a statement based on the evaluation of a boolean expression.
<pre>_
while-statement:
    *while (* expression *)* embedded-statement
_</pre>

== {{{do}}} statements ==
The {{{do}}} statement executes one or more times a statement based on the evaluation of boolean expression.
<pre>_
do-statement:
    *do* embedded-statement *while (* expression *);*  
_</pre>

== {{{for}}} statements ==
The {{{for}}} statement executes an initialization statement and then execute repeatedly a statement and an iterator statement based on the evaluation of a boolean expression.
<pre>_
for-statement:
    *for (* local-declaration-statement,,opt,, *;* expression,,opt,, *;* expression-statement-list,,opt,, *)* embedded-statement
_</pre>
<pre>_
expression-statement-list:
    expression-statement
    expression-statement-list expression-statement
_</pre>

== {{{foreach}}} statements ==
The {{{foreach}}} statements executes a statement for each element of an array, or for each value of an instance of {{{java.lang.Iterable<T>}}}.
<pre>_
foreach-statement:
    *foreach (* type identifier *in* expression *)* embedded-statement
    *foreach ( var* identifier *in* expression *)* embedded-statement
_</pre>

== {{{break}}} statements ==
The {{{break}}} statement transfers control just after the most nested enclosing loop or {{{switch}}}.
<pre>_
break-statement:
    *break ;* 
_</pre>

== {{{continue}}} statements ==
The {{{continue}}} statement ends the current iteration of the most nested enclosing loop.
<pre>_
continue-statement:
    *continue ;* 
_</pre>

== {{{goto}}} statements ==
The {{{goto}}} statement transfers control to a label. {{{goto case}}} and {{{goto default}}} forms transfer control inside the most nested enclosing {{{switch}}}.
<pre>_
goto-statement:
    *goto* identifier *;* 
    *goto case* expression *;* 
    *goto default* 
_</pre>

== {{{return}}} statements ==
A {{{return}}} statement sets the result, if any, of the current method and stops its execution. Control is transfered to the caller of the method.
<pre>_
    *return* expression,,opt,, *;* 
_</pre>

== {{{throw}}} statements ==
The {{{throw}}} statement throws an exception. The short form of the statement must be called inside a {{{catch}}} block to throw the handled exception.
<pre>_
throw-statement:
    *throw* expression,,opt,, *;* 
_</pre>

== {{{try}}} statements ==
The {{{try}}} statement is used to handle exceptions.
<pre>_
try-statement:
    *try* block catch-clauses
    *try* block *finally* block
    *try* block catch-clauses *finally* block
_</pre>
<pre>_
catch-clauses:
    specific-catch-clauses general-catch-clause,,opt,, 
    specific-catch-clauses,,opt,, general-catch-clause
_</pre>
<pre>_
specific-catch-clauses:
    specific-catch-clause
    specific-catch-clauses specific-catch-clause
_</pre>
<pre>_
specific-catch-clause:
    *catch (* class-type identifier,,opt,, *)* block
_</pre>
<pre>_
general-catch-clause:
    *catch* block
_</pre>

== {{{synchronized}}} statements ==
The {{{synchronized}}} statement obtains a mutual-exclusion lock, executes a statement and release the lock.
<pre>_
synchronized-statement:
    *synchronized (* expression *)* embedded-statement
_</pre>

== {{{using}}} statements ==
The {{{using}}} statement executes a statement and release some specified resources.
<pre>_
using-statement:
    *using (* local-declaration-statement *)* embedded-statement
    *using (* expression *)* embedded-statement
_</pre>
The compiler use the {{{stab.lang.Dispose}}} annotation to determine which method must be called to dispose the object. The compiler is shipped with a library that adds this annotation to {{{java.io.Closeable}}} (see [StabCompiler#annotatedlibs]).

The code sample:
{{{
int c;
using (var reader = new FileReader("file.txt")) {
    c = reader.read();
}
}}}
is equivalent to:
{{{
int c;
var reader = new FileReader("file.txt");
try {
    c = reader.read();
} finally {
    if (reader != null) reader.close();
}
}}}
== {{{yield}}} statements ==
A {{{yield return}}} statement sets the value of an iteration inside an iterator block. A {{{yield break}}} statement exits the iterator block. Both {{{java.lang.Iterable<T>}}} and {{{java.util.Iterator<T>}}} can be returned by an iterator block.
<pre>_
yield-statement:
    *yield return* expression *;* 
    *yield break ;*
_</pre>

For example to declare a method which returns the elements of a list of strings in reverse order in an Iterable, just write:
{{{
public Iterable<String> reverse(List<String> list) {
    for (int i = list.size() - 1; i >= 0; --i) {
        yield return list.get(i);
    }
}
}}}

Support of primitive type iterators are supported by using {{{stab.lang.IntIterable}}}, {{{stab.lang.DoubleIterable}}}, etc...

This method provides an iterator over a range of integer values without involving any boxing/unboxing:
{{{
    IntIterable range(int start, int count) {
        while (count-- > 0) {
            yield return start++;
        }
    }
}}}

It can then be used as the iterator of a [AllStatements#_{{{foreach}}}_statements_ foreach] statement:
{{{
    foreach (var i in range(0, 10) {
        System.out.println("i = " + i);
    }
}}}