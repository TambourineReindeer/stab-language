#summary Describes the lexical structure of the Stab programming language.
<wiki:toc max_depth="3"/>

= Lexical analysis =
The process of scanning a source file is described by the grammar productions:
<em><pre>
input:
    input-section,,opt,, 
    
input-section:
    input-section-part
    input-section input-section-part
    
input-section-part:
    input-elements,,opt,, 
    pp-directive
    
input-elements:
    input-element
    input-elements input-element
    
input-element:
    whitespace
    comment
    token
</pre></em>

= Newlines =
<em><pre>
new-line-character:
    *Carriage return (U+000D)* 
    *Line feed (U+000A)* 
    *Next line (U+0085)* 
    *Line separator (U+2028)* 
    *Paragraph separator (U+2029)* 
    
new-line:
    *Carriage return (U+000D)* 
    *Line feed (U+000A)* 
    *Carriage return (U+000D) immediately followed by Line feed (U+000A)* 
    *Next line (U+0085)* 
    *Line separator (U+2028)* 
    *Paragraph separator (U+2029)* 
</pre></em>

= Whitespaces =
<em><pre>
whitespace:
    *Space (U+0020)* 
    *Horizontal tab (U+0009)* 
    *Vertical tab (U+000B)* 
    *Form feed (U+000C)* 
</pre></em>

= Comments =
The language supports traditional C++ comments:
<em><pre>
comment:
    single-line-comment
    delimited-comment
    
single-line-comment:
    *//* input-characters,,opt,,
    
input-characters:
    input-character
    input-characters input-character
    
input-character:
    *Any Unicode character except a* new-line-character
    
delimited-comment:
    */`*` Any Unicode characters except the `*`/ sequence `*`/*
</pre></em>

= Tokens =
<em><pre>
token:
    identifier
    *@* identifier
    keyword
    *@* keyword
    integer-literal
    real-literal
    character-literal
    string-literal
    separator
</pre></em>

== Unicode escape sequences ==
Unicode escape sequences can be part of identifiers, strings and character.
<em><pre>
unicode-escape-sequence:
    *\u* hex-digit hex-digit hex-digit hex-digit
    *\U* hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit
</pre></em>

== Identifiers ==
The @ character can be added before an identifier or a keyword. The resulting token is an identifier without the @ character.
It is useful to use keywords as identifiers when a library has been written in Java.
<em><pre>
identifier:
    identifier-start identifier-parts,,opt,,
    
identifier-start:
    *Any character or* unicode-escape-sequence *where java.lang.Character.isJavaIdentifierStart() is true* 
    
identifier-parts:
    identifier-part
    identifier-parts identifier-part
    
identifier-part:
    *Any character or* unicode-escape-sequence *where java.lang.Character.isJavaIdentifierPart() is true*
</pre></em>

== Keywords ==
The following tokens cannot be used as identifier except when prefixed with @:
<tt>
|| abstract || as || boolean || break || byte || case || catch ||
|| char || class || continue || default || delegate || double || do ||
|| else || enum || false || final || finally || float || for ||
|| foreach || goto || if || in || instanceof || int || interface ||
|| long || package || native || new || null || override || params ||
|| partial || private || protected || public || return || short || sizeof ||
|| static || strictfp || super || switch || synchronized || this || throw ||
|| transient || true || try || typeof || using || virtual || void ||
|| volatile || where || while ||
</tt>

These identifiers are considered as keywords when used in some places in the code:
<tt>
|| ascending || by || descending || equals || from || get || group ||
|| into || join || let || on || orderby || select || set ||
|| value || var || where || yield ||
</tt>

== Integer literals ==
Values of types {{{int}}} and {{{long}}} can be represented as integer literals:
<em><pre>
integer-literal:
    decimal-digits long-type,,opt,, 
    0x hex-digits long-type,,opt,, 
    0X hex-digits long-type,,opt,, 
    
decimal-digits:
    decimal-digit
    decimal-digits decimal-digit
    
decimal-digit:
    *One of 0 1 2 3 4 5 6 7 8 9* 
    
hex-digits:
    hex-digit
    hex-digits hex-digit
    
hex-digit:
    *One of 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f* 
    
long-type:
    *One of l L* 
</pre></em>
The values without the optional 'L' suffix and outside of the range of {{{int}}} values are considered as {{{long}}} literals.

== Real literals ==
Values of types {{{float}}} and {{{double}}} can be represented as real literals:
<em><pre>
real-literal:
    decimal-digits . decimal-digits exponent-part,,opt,, real-type,,opt,, 
    . decimal-digits exponent-part,,opt,, real-type,,opt,,
    decimal-digits exponent-part real-type,,opt,, 
    decimal-digits real-type
    
exponent-part:
    *e +*,,opt,, decimal-digits
    *e -*,,opt,, decimal-digits
    *E +*,,opt,, decimal-digits
    *E -*,,opt,, decimal-digits
    
real-type:
    *One of f F d D*
</pre></em>

== Character literals ==
Values of type {{{char}}} can be represented as character literals:
<em><pre>
character-literal:
    *'* character *'* 
    
character:
    *Any character except quote (U+0027), backslash (U+005C), and* new-line-character
    simple-escape-sequence
    hexadecimal-escape-sequence
    unicode-escape-sequence
    
simple-escape-sequence:
    *One of \' \" \\ \0 \a \b \f \n \r \t \v* 
    
hexadecimal-escape-sequence:
    *\x* hex-digit hex-digit,,opt,, hex-digit,,opt,, hex-digit,,opt,,
</pre></em>
The characters represented by simple escape sequences are:
|| *Escape sequence* || *Unicode* ||
|| \' || U+0027 ||
|| \" || U+0022 ||
|| \\ || U+005C ||
|| \0 || U+0000 ||
|| \a || U+0007 ||
|| \b || U+0008 ||
|| \f || U+000C ||
|| \n || U+000A ||
|| \r || U+000D ||
|| \t || U+0009 ||
|| \v || U+000B ||

== String literals ==
Values of type {{{java.lang.String}}} can be represented as string literals:
<em><pre>
string-literal:
    *"* string-literal-characters,,opt,, *"* 
    *@"* verbatim-string-characters,,opt,, *"* 
    
string-literal-characters:
    string-literal-character
    string-literal-characters string-literal-character
    
string-literal-character:
    *Any character except double quote (U+0022), backslash (U+005C), and* new-line-character
    simple-escape-sequence
    hexadecimal-escape-sequence
    unicode-escape-sequence
    
verbatim-string-characters:
    verbatim-string-character
    verbatim-string-characters verbatim-string-character
    
verbatim-string-character:
    *Any character except double quote (U+0022)* 
    *""*
</pre></em>
Verbatim string literals can be used to represent strings that would otherwise require a lot of escape sequences if represented using the traditional format:
{{{
var s1 = @"C:\tmp\f.txt";
var s2 = @"line 1
line 2
line 3";
}}}

== Separators ==
<tt>
|| { || } || [ || ] || ( || ) || . || , || : || ; ||
|| + || - || `*` || / || % || & || | || ^ || ! || ~ ||
|| = || < || > || ? || ?? || :: || ++|| -- || &&  || | | ||
|| == || != || <= || >= || += || -= || *= || /= || %= || &= ||
|| |= || ^= || << || <<= || => ||
</tt>

To avoid ambiguities in generic parameter lists:
  * >> is the composition of two >
  * >>= is the composition of > and >=.
  * >>> is the composition of three >
  * >>>= is the composition of >, > and >=

= Pre-processing directives =
The preprocessor support in Stab is directly borrowed from the mecanism described in the [http://msdn.microsoft.com/en-us/library/aa645596(v=VS.71).aspx C# specification].

Symbols can be defined externally using the {{{-d}}} option of the compiler. For example the option to define S1 and S2 symbols is {{{-d:S1;S2}}}.