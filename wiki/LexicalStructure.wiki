#summary Describes the lexical structure of the Stab programming language.

<wiki:toc max_depth="3"/>

= Lexical analysis =

The process of scanning a source file is described by the grammar productions:
<blockquote><em>
input:
    input-section <sub>opt</sub>
input-section:
    input-section-part<br/>
    input-section input-section-part
input-section-part:
    input-elements <sub>opt</sub><br/>
    preprocessor-directive
input-elements:
    input-element<br/>
    input-elements input-element
input-element:
    whitespace<br/>
    comment<br/>
    token
</em></blockquote>
The _preprocessor-directive_ production is detailed in this page: PreprocessorDirectives.

= Newlines =
<blockquote><em>
new-line-character:
    <b>Carriage return (U+000D)<br/>
    Line feed (U+000A)<br/>
    Next line (U+0085)<br/>
    Line separator (U+2028)<br/>
    Paragraph separator (U+2029)</b> 
</em></blockquote>
<blockquote><em>
new-line:
    <b>Carriage return (U+000D)<br/>
    Line feed (U+000A)<br/>
    Carriage return (U+000D)</b> immediately followed by <b>Line feed (U+000A)<br/>
    Next line (U+0085)<br/>
    Line separator (U+2028)<br/>
    Paragraph separator (U+2029)</b> 
</em></blockquote>

= Whitespaces =
<blockquote><em>
whitespace:
    <b>Space (U+0020)<br/>
    Horizontal tab (U+0009)<br/>
    Vertical tab (U+000B)<br/>
    Form feed (U+000C)</b> 
</em></blockquote>

= Comments =
The language supports the traditional C++ comments:
<blockquote><em>
comment:
    single-line-comment<br/>
    delimited-comment
single-line-comment:
    // input-characters <sub>opt</sub>
input-characters:
    input-character<br/>
    input-characters input-character
input-character:
    <b>Any Unicode character except a</b> new-line-character
delimited-comment:
    /`*` <b>Any Unicode characters except the sequence `*`/</b> `*`/
</em></blockquote>

= Tokens =
<blockquote><em>
token:
    identifier<br/>
    @identifier<br/>
    @keyword<br/>
    keyword<br/>
    integer-literal<br/>
    real-literal<br/>
    character-literal<br/>
    string-literal<br/>
    separator
</em></blockquote>

== Unicode escape sequences ==
Unicode escape sequences can be part of identifiers, strings and character.
<blockquote><em>
unicode-escape-sequence:
    \u hex-digit hex-digit hex-digit hex-digit<br/>
    \U hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit
</em></blockquote>

== Identifiers ==
The @ character can be added before an identifier or a keyword. The resulting token is an identifier without the @ character.
It is useful to use keywords as identifiers when a library has been written in Java.
<blockquote><em>
identifier:
    identifier-start identifier-parts <sub>opt</sub>
identifier-start:
    <b>Any character or</b> unicode-escape-sequence <b>where java.lang.Character.isJavaIdentifierStart() is true</b>  
identifier-parts:
    identifier-part<br/>
    identifier-parts identifier-part
identifier-part:
    <b>Any character or</b> unicode-escape-sequence <b>where java.lang.Character.isJavaIdentifierPart() is true</b>
</em></blockquote>

== Keywords ==
The following tokens cannot be used as identifier except when prefixed with @:
<tt>
|| abstract || as || boolean || break || byte || case || catch ||
|| char || class || continue || default || delegate || double || do ||
|| else || enum || false || final || finally || float || for ||
|| foreach || goto || if || in || instanceof || int || interface ||
|| long || package || native || new || null || override || params ||
|| partial || private || protected || public || return || short || sizeof ||
|| static || strictfp || super || switch || synchronized || this || throw ||
|| transient || true || try || typeof || using || virtual || void ||
|| volatile || where || while ||
</tt>

These identifiers are considered as keywords when used in some places in the code:
<tt>
|| ascending || by || descending || equals || from || get || group ||
|| into || join || let || on || orderby || select || set ||
|| value || var || where || yield ||
</tt>

== Integer literals ==
Values of types {{{int}}} and {{{long}}} can be represented as integer literals:
<blockquote><em>
integer-literal:
    decimal-digits long-type <sub>opt</sub><br/>
    0x hex-digits long-type <sub>opt</sub><br/>
    0X hex-digits long-type <sub>opt</sub><br/>
decimal-digits:
    decimal-digit<br/>
    decimal-digits decimal-digit
decimal-digit:
    <b>One of</b> 0 1 2 3 4 5 6 7 8 9
hex-digits:
    hex-digit<br/>
    hex-digits hex-digit
hex-digit:
    <b>One of</b> 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
long-type:
    l <b>or</b> L
</em></blockquote>
The values without the optional 'L' suffix and outside of the range of {{{int}}} values are considered as {{{long}}} literals.

== Real literals ==
Values of types {{{float}}} and {{{double}}} can be represented as real literals:
<blockquote><em>
real-literal:
    decimal-digits . decimal-digits exponent-part <sub>opt</sub> real-type <sub>opt</sub><br/>
    . decimal-digits exponent-part <sub>opt</sub> real-type <sub>opt</sub><br/>
    decimal-digits exponent-part real-type <sub>opt</sub><br/>
    decimal-digits real-type
exponent-part:
    e +<sub>opt</sub> decimal-digits<br/>
    e -<sub>opt</sub> decimal-digits<br/>
    E +<sub>opt</sub> decimal-digits<br/>
    E -<sub>opt</sub> decimal-digits
real-type:
    <b>One of</b> f F d D
</em></blockquote>

== Character literals ==
Values of type {{{char}}} can be represented as character literals:
<blockquote><em>
character-literal:
    ' character '
character:
    <b>Any character except quote (U+0027), backslash (U+005C), and</b> new-line-character<br/>
    simple-escape-sequence<br/>
    hexadecimal-escape-sequence<br/>
    unicode-escape-sequence
simple-escape-sequence:
    <b>One of</b> \' \" \\ \0 \a \b \f \n \r \t \v
hexadecimal-escape-sequence:
    \x hex-digit hex-digit <sub>opt</sub> hex-digit <sub>opt</sub> hex-digit <sub>opt</sub>
</em></blockquote>
The characters represented by simple escape sequences are:
|| *Escape sequence* || *Unicode* ||
|| \' || U+0027 ||
|| \" || U+0022 ||
|| \\ || U+005C ||
|| \0 || U+0000 ||
|| \a || U+0007 ||
|| \b || U+0008 ||
|| \f || U+000C ||
|| \n || U+000A ||
|| \r || U+000D ||
|| \t || U+0009 ||
|| \v || U+000B ||

== String literals ==
Values of type {{{java.lang.String}}} can be represented as string literals:
<blockquote><em>
string-literal:
    " string-literal-characters <sub>opt</sub> "<br/>
    @" verbatim-string-characters <sub>opt</sub> "
string-literal-characters:
    string-literal-character<br/>
    string-literal-characters string-literal-character
string-literal-character:
    <b>Any character except double quote (U+0022), backslash (U+005C), and</b> new-line-character<br/>
    simple-escape-sequence<br/>
    hexadecimal-escape-sequence<br/>
    unicode-escape-sequence
verbatim-string-characters:
    verbatim-string-character<br/>
    verbatim-string-characters verbatim-string-character
verbatim-string-character:
    <b>Any character except double quote (U+0022)</b><br/>
    " "
</em></blockquote>
Verbatim string literals can be used to represent strings that would otherwise require a lot of escape sequences if represented using the traditional format:
{{{
var s1 = @"C:\tmp\f.txt";
var s2 = @"line 1
line 2
line 3";
}}}

== Separators ==
<tt>
|| { || } || [ || ] || ( || ) || . || , || : || ; ||
|| + || - || `*` || / || % || & || | || ^ || ! || ~ ||
|| = || < || > || ? || ?? || :: || ++|| -- || &&  || | | ||
|| == || != || <= || >= || += || -= || *= || /= || %= || &= ||
|| |= || ^= || << || <<= || => ||
</tt>

To avoid ambiguities in generic parameter lists:
  * >> is the composition of two >
  * >>= is the composition of > and >=.
  * >>> is the composition of three >
  * >>>= is the composition of >, > and >=